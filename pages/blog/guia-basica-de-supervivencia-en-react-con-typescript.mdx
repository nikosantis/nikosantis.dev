import LayoutPost from 'components/layout/post'
import { getPostByUrl } from 'lib/posts'

Para muchas personas que llevan un tiempo aprendiendo, practicando y ejerciendo el uso de **React** en su trabajo o en proyectos de aprendizaje, el tener que usar **TypeScript**, es un dolor de cabeza.

Es muy sencillo decir que TypeScript es f√°cil cuando ya sabes, pero no tanto as√≠ para quienes reci√©n vienen aprendiendo las maravillas de este lenguaje de programaci√≥n construido sobre **JavaScript**.

He querido compartir hace un buen tiempo una peque√±a **Gu√≠a b√°sica de Supervivencia en React con TypeScript** y ahora es el momento.

_Disclaimer n¬∫1: Es importante se√±alar que es una gu√≠a b√°sica, sin profundizar demasiado en TypeScript o en las diversas formas de hacer algo. Tambi√©n quiero agregar que al ser una gu√≠a b√°sica, se considera el uso de TypeScript en un proyecto que ya tiene todo configurado para usarlo, no obstante, m√°s adelante publicar√© m√°s sobre c√≥mo configurar un proyecto en React y Nextjs con TypeScript._
_Disclaimer n¬∫2: En mi uso cotidiano utilizo VSCODE por ende, todos los ejercicios de este post est√°n probados en VSCODE. Aunque tambi√©n puedes probar todo esto en el [playground oficial de TypeScript](https://www.typescriptlang.org/es/play 'playground oficial de TypeScript')._

## 1. Introducci√≥n

TypeScript es un lenguaje de programaci√≥n Open Source construido sobre JavaScript, que en esencia, le a√±ade tipos est√°ticos a JS.

Los tipos (types) proveen una manera de describir la forma de un objeto, otorgando mejor documentaci√≥n y permitiendo a TypeScript validar que el c√≥digo funciona correctamente.

Para React, TypeScript le permite trabajar de una manera mucho m√°s ordenada, tratando de disminuir el mal uso de ciertos componentes, props, estados, hooks, funciones, etc.

En esta primera parte, trataremos de manera muy b√°sica, algunos aspectos esenciales de TypeScript.

Por ejemplo, podemos tener una constante que es un `string`, sobre la cual queramos definir un `number`. TypeScript nos dir√° de inmediato que habr√° un error en esta constante. Recordar que VSCODE nos mostrar√° el error y en especial si se utiliza la extensi√≥n \*_[Error Lens](https://marketplace.visualstudio.com/items?itemName=usernamehw.errorlens 'Error Lens')_

```ts
const unaConstanteSimple: string = 32
// error => El tipado 'number' no se puede asignar al tipado 'string'
```

De la misma manera si lo defines al rev√©s, es decir, que sea un `number` y luego le asignas un `string`.

En una funci√≥n, el tema es similar, aunque debemos considerar que se le agregan un poco m√°s de tipado, esto porque puedes tipar el argumento, como tambi√©n lo que la funci√≥n retorna. Revisemos el siguiente ejemplo:

```js
// una funci√≥n que retorna un argumento en may√∫scula
function unaFuncion(argumento) {
  return argumento.toUpperCase()
}
```

En JavaScript sabemos que el argumento que ingresar√° har√° que el m√©todo `toUpperCase` convierta el argumento en may√∫scula. No obstante, qu√© sucede si ingresamos un `number` o incluso, una `funci√≥n` en el argumento?

```js
unaFuncion(32)
unaFuncion(function otraFuncion() {
  return 32
})
// Error => Uncaught TypeError: argumento.toUpperCase is not a function
```

Recibiremos un error en ambos casos.
Bueno, aqu√≠ TypeScript comienza a tomar sentido, porque vamos a espec√≠ficar que la funci√≥n solo podr√° recibir un `string`.

```ts
// una funci√≥n que retorna un argumento en may√∫scula
function unaFuncion(argumento: string) {
  return argumento.toUpperCase()
}
```

En este caso, estamos siendo muy espec√≠ficos en que el argumento siempre deber√° ser√° un `string`. Aqu√≠ si intentamos ingresar un `number` o una `funci√≥n` como el ejemplo anterior, nos aparecer√° un error similar al del primer ejemplo.

Al mismo tiempo, una funci√≥n, como mencion√©, tambi√©n se puede tipar el retorno.
Por defecto, TypeScript (y tambi√©n JavaScript si posicionas el mouse sobre la funci√≥n) nos dir√° que la funci√≥n `unaFuncion` retornar√° un `string`. Pero, para este ejemplo, queremos ser m√°s espec√≠ficos y queremos ponerlo.

```ts
function unaFuncion(argumento: string): string {
  return argumento.toUpperCase()
}
```

Finalmente, una √∫ltima prueba. Si cambiamos el `return` por `Number(argumento)`, tambi√©n tendremos un error. Porque ya hab√≠amos dicho que el `return` deb√≠a ser un `string`.

Luego de este peque√±o ejemplo, podremos avanzar un poco m√°s en esta gu√≠a b√°sica.

Existen diferentes tipados para usar:

Los primitivos: `string`, `number` y `boolean` (este √∫ltimo indica que puede ser verdadero o falso).

Tambi√©n tenemos otro tipado llamado `any`. Este lo ver√°s mucho y en la pr√°ctica indica que puede ser cualquier tipo de tipado.

Con estas primitivas podemos crear otros tipados combinados. Por ejemplo, con un `array`.

```ts
const unArray: number[] = [1, 2, 3] // => esto ser√° un array con n√∫meros [1,2,3].
const otroArray: Array<number> = [1, 2, 3]
```

Te habr√°s dado cuenta que he escrito lo mismo de dos maneras. En ambos casos, estamos asignado el mismo tipado. Te muestro esto, porque es muy t√≠pico que en algunos lados encontrar√°s de ambas maneras esto.

Otro ejemplo, pero con objetos.

```ts
const unObjeto: { id: string } = { id: '1' }
```

Ahora bien, si el objeto tiene muchas propiedades, puede ser que tipar este objeto pueda ser un poco _verbose_. Aqu√≠ TypeScript nos regala una manera m√°s pr√°ctica de hacerlo, definiendo un `type`.

```ts
type MiObjetoType = {
  id: string
  nombre: string
  edad: number
}
const unObjeto: MiObjetoType = { id: '1', nombre: 'Nikolas', edad: 32 }
```

Y este mismo ejemplo, lo podemos combinar con un array.

```ts
type MiObjetoType = {
  id: string
  nombre: string
  edad: number
}
const otroObjetoConArray: MiObjetoType[] = [
  { id: '1', nombre: 'Nikolas', edad: 32 },
  { id: '2', nombre: 'Angie', edad: 33 }
]
```

Yo siempre trato de definir mis tipados con la palabra Type al final, para establecer un nombre coherente que le permit a otras personas entender mi c√≥digo.

> Cuando escribimos c√≥digo, siempre estamos escribiendo para una m√°quina/computadora, la cual comprender√° si se ha escrito de manera correcta, lo que debe realizar. Pero muchas veces, si bien, el c√≥digo funciona, cuando llega otra persona a leer nuestro c√≥digo y trata de leerlo, se encuentra con que no es muy f√°cil de entender. Por ende, siempre debemos tratar de escribir c√≥digo para la computadora y c√≥digo para humanos.

Tambi√©n podr√≠amos haber definido el tipado desde antemano que era un array, agregando los corchetes al final `[]` o escribir `Array<...>`. Pero a veces, puede que el mismo tipado lo debas utilizar en otro lado.

Para finalizar, tambi√©n existe lo que se llama `interface`, que funciona de manera similar a `type` pero tiene sus diferencias.

```ts
interface MiObjetoInterface {
  id: string
  nombre: string
  edad: number
}
const objetoConArray: MiObjetoInterface[] = [
  { id: '1', nombre: 'Nikolas', edad: 32 },
  { id: '2', nombre: 'Angie', edad: 33 }
]
```

Si te fijas, la `interface` no tiene el signo '='. Tiene muchas m√°s diferencias que lo del signo, pero no quiero entrar en tanto detalle, no obstante, en el punto n¬∫ 3 del post, ahondaremos un poco m√°s en sus diferencias.

Te recomiendo ahondar mucho m√°s en cursos, tutoriales y la documentaci√≥n para aprender detalles. Esto es solo una peque√±a parte.

## 2.- Tipando un Componente

Hay muchas formas de tipar un componente en React y te mostrar√© las m√°s usadas.

> Te quiero dar una pista antes de continuar. Si utilizas VSCODE y est√°s trabajando en un proyecto que ya est√° configurado con TypeScript, puedes poner el mouse sobre un componente y te mostrar√° su tipado. Si haces esto en JavaScript te dir√° que el tipado es `any`.

La forma m√°s b√°sica es utilizar lo que se llama "tipado inferido".

```jsx
function UnComponente() {
  return <h1>Hola</h1>
}
```

Aqu√≠ si ponemos el mouse sobre el nombre del componente, el editor de c√≥digo nos dir√° que es un `JSX.Element`.

As√≠ que una simple manera de definir un componente ser√≠a:

```tsx
function UnComponente(): JSX.Element {
  return <h1>Hola</h1>
}
```

Esta es la manera m√°s sencilla.

Considera que para un componente con Arrow Function ser√≠a as√≠:

```tsx
const UnComponente = (): JSX.Element => {
  return <h1>Hola</h1>
}
```

Definir de esta manera, solo depender√° de la configuraci√≥n del proyecto.
Hay proyectos donde los componentes (as√≠ las funciones normales tambi√©n), no requiere tiparlas seg√∫n la configuraci√≥n de ESLINT, sino que se har√≠a de forma inferida (no deber√≠as hacer nada). Aunque a veces, hay que ser un poco m√°s estricto. En mi caso, en los proyectos que configuro, soy m√°s estricto, no obstante, utilizar el truco del mouse sobre el componente o funci√≥n es una buena idea, pero no siempre es recomendable, porque si al inicio el componente retorna JSX, est√° bien, pero si en alg√∫n momento tienes un return NULL, el tipado va a fallar, ya que ya no ser√≠a JSX.Element.

Otra forma, que es muy probable que ver√°s en diversos proyectos con TS, es usando el tipado que trae React (@types/react) que es `FC` (puede que en algunos lados en vez de FC veas `FunctionComponent`, pero FC es lo mismo, solo que abreviado).

```tsx
const UnComponente: React.FC = () => {
  return <h1>Hola</h1>
}
```

Tambi√©n lo puedes hacer importando FC desde React.

```tsx
import { FC } from 'react'
const UnComponente: FC = () => {
  return <h1>Hola</h1>
}
```

> Recuerda que actualmente, en la √∫ltima versi√≥n de React (17), no es necesario importar React de 'react'.

Aqu√≠ hay un tema muy importante de mencionar.
El tipado FC, al igual que JSX.Element, es una `interface`. Las interfaces pueden recibir argumentos (como una funci√≥n).

En el archivo TS de React podemos encontrar que el tipado viene as√≠:

```ts
// Type definitions for React 17.0
type FC<P = {}> = FunctionComponent<P>

interface FunctionComponent<P = {}> {
  (props: PropsWithChildren<P>, context?: any): ReactElement<any, any> | null
  propTypes?: WeakValidationMap<P>
  contextTypes?: ValidationMap<any>
  defaultProps?: Partial<P>
  displayName?: string
}
```

Y aqu√≠ podemos ver unas cosas importantes de mencionar.

El tipado `FC` incluye dentro de sus props, la prop `children`, por lo cual, como veremos a continuaci√≥n, no es necesario tipar children con FC. Al mismo tiempo, incluye de manera opcional, `propTypes`, `contextTypes`, `defaulProps` y `displayName`.

Si nunca has usado estas props, no te preocupes, no es momento de hablar de ellas, pero si puedo decir, que FC trae todo esto dentro. Tambi√©n debo decirte que existen algunos problemas asociados a las defaultProps y tambi√©n con children respecto a este tipado, pero en casos espec√≠ficos, pero casi siempre, te funcionar√°.

Si el proyecto que te toque trabajar tiene tipados inferidos en sus componentes, no ser√≠a necesario tipar el componente y solo quedar√≠an como elementos JSX. No obstante, si observas proyectos de dependencias que se usan mucho en React, ver√°s diversas maneras.

Personalmente, me gusta definir mis componentes como funciones cl√°sicas `function` y solo tipar las props. Para evitar problemas con FC y todo eso que hablo arriba, me quedo de la manera m√°s simple. JSX.Element!

```jsx
function UnComponente() {
  return <h1>Hola</h1>
}
```

## 3. Tipando Props

Aqu√≠ viene la gran pregunta. ¬øType o Interface?.

Las interfaces son diferentes a los tipos en TypeScript, pero tienen usos muy similares en lo que respecta a React.

Yo sigo una regla muy √∫til para esto que viene de [React TypeScript Cheatsheets](https://react-typescript-cheatsheet.netlify.app/ 'React TypeScript Cheatsheets').

- Siempre usar `interface` para las definiciones de API p√∫blica cuando se est√° escribiendo una librer√≠a o las definiciones de tipo de ambiente de una librer√≠a de terceros.
- Considerar usar `type` para las props y estado de los componentes de React, porque tiene m√°s restricciones.

Otro elemento importante, es que los `types` son √∫tiles para tipos de uni√≥n `type SomeType = AType | BType`, mientras que las `interface` son mejores para declarar formas de diccionario y luego `implement` o `extend`.

| Aspecto                                            | Type | Interface |
| -------------------------------------------------- | :--: | :-------: |
| Puede describir funciones                          |  ‚úÖ  |    ‚úÖ     |
| Puede describir constructores                      |  ‚úÖ  |    ‚úÖ     |
| Puede describir tuplas                             |  ‚úÖ  |    ‚úÖ     |
| Se puede extender                                  |  ‚ö†Ô∏è  |    ‚úÖ     |
| Se puede extender Classes                          |  üö´  |    ‚úÖ     |
| Se puede implementar Classes                       |  ‚ö†Ô∏è  |    ‚úÖ     |
| Se puede intersectar con otro de su mismo tipo     |  ‚úÖ  |    ‚ö†Ô∏è     |
| Se puede crear una uni√≥n con otro de su mismo tipo |  ‚úÖ  |    ‚ö†Ô∏è     |
| Se puede usar para crear tipos mapeados            |  ‚úÖ  |    üö´     |
| Se puede mapear con tipos mapeados                 |  ‚úÖ  |    ‚úÖ     |
| Se expande en mensajes de error y logs             |  ‚úÖ  |    üö´     |
| Se puede aumentar                                  |  üö´  |    ‚úÖ     |
| Puede ser recursivo                                |  ‚ö†Ô∏è  |    ‚úÖ     |

‚ö†Ô∏è: en algunos casos

Aqu√≠ unos ejemplos de algunos tipados:

```tsx
type Props = {
  message: string
  count: number
  disabled: boolean
  // array de string
  names: string[]
  // string literales utilizando una "uni√≥n"
  status: 'waiting' | 'success'
  // cualquier objeto, aunque no muy usado.
  obj: object
  // casi igual a object, pero m√°s exactamente Object.
  obj2: {}
  // objeto con propiedades tipadas.
  obj3: {
    id: string
    title: string
  }
  // array de objetos
  objArr: {
    id: string
    title: string
  }[]
  // un objeto con propiedades con el mismo tipado
  dict1: {
    [key: string]: OtroType
  }
  // equivalente a dict1.
  dict2: Record<string, OtroType>
  // funci√≥n que no retorna nada
  someFunction: () => void
  // funci√≥n que incluye argumentos
  otherFunction: (id: string) => void
  // funci√≥n con tipado react - React.SyntheticEvent o import {SyntheticEvent} from 'react'
  onChange: (event: React.SyntheticEvent) => void
  // tipado opcional
  optionalProp?: SomeOptionalType
  // tipado del m√©todo dispatch del hook useState
  someSetState: React.Dispatch<React.SetStateAction<SomeUseStateType>>
}
```

Son solo algunas muestras.

Muchas veces te encontrar√°s con argumentos, m√©todos o funciones de alguna librer√≠a, o incluso, cosas internas del mismo React, lo mejor es posicionar el mouse sobre el mouse sobre el elemento y de inmediato, tendr√°s una muestra del tipado y poder copiarlo y buscar los `types` o `interface`. Otra opci√≥n es utilizar un truco que hablaremos m√°s adelante.

### Tipar "children"

Muchas veces, por no saber c√≥mo tipar `children`, demasiadas personas se han equivocado y generado errores en la compilaci√≥n, no obstante, es primordial saber c√≥mo tipar children. Como tambi√©n otras props espec√≠ficas que podr√≠as necesitar.

```tsx
type Props = {
  // la mejor manera de tipar children. Ojo con unos types o interfaces que dicen React.Children u otros, no hablan de lo mismo, aunque as√≠ lo parezca.
  children: React.ReactNode // o tambi√©n import { ReactNode } from 'react'
  // tipar una render prop
  functionChildren: (name: string) => React.ReactNode
  // props de estilos
  styles?: React.CSSProperties
  // una funci√≥n con evento de formulario => event.target
  onChange?: React.FormEventHandler<HTMLInputElement>
}
```

Insisto, son solo algunas muestras, pero sin duda, te dar√°n algunas pistas para hacer muchas m√°s cosas. Revisa algunas librer√≠as que uses y que est√©n hechas en TypeScript. Puede que sea mucho m√°s complejo tomar librer√≠as con solo JavaScript y que tienen @DefinitelyTyped aparte. Hay que navegar y buscar.

### Tipar Hooks

Te quiero aliviar varios dolores de cabeza en esta parte. Si bien, muchas veces se puede inferir tipados, hay cosas que tambi√©n requieren un paso extra para mejorar el comportamiento y tambi√©n a√±adir mayor control de tu c√≥digo.

**useState**

Como dije, la inferencia de tipos funciona bastante bien.

```tsx
// se infiere que isValid es un boolean, y que setIsValid recibir√° solo booleans
const [isValid, setIsValid] = useState(false)
```

Aunque s√© que por culpa de muchos tutoriales, te has agarrado la ma√±a de iniciar cosas en null (claramente es una broma, muchas veces tenemos que hacerlo), pero luego su comportamiento har√° que sea un string, o incluso 3 tipados diferentes.

```tsx
const [someData, setSomeData] = useState<SomeDataType | null>(null)
// otros ejemplos
const [text, setText] = useState<string>('')
const [count, setCount] = useState<number>(0)
```

**useReducer**

Una forma r√°pida de tipar es utilizar la t√©cnica del `typeof`.

```tsx
import { useReducer } from 'react'

const INITIAL_STATE = {
  count: 0,
  text: ''
}

type ActionType =
  | { type: 'increment'; payload: number }
  | { type: 'decrement'; payload?: number }
  | { type: 'set_text'; payload: string }
  | { type: 'reset' }

function reducer(state: typeof INITIAL_STATE, action: ActionType) {
  switch (action.type) {
    case 'increment':
      return { ...state, count: state.count + action.payload }
    case 'decrement':
      return { ...state, count: state.count - (action.payload || 1) }
    case 'set_text':
      return { ...state, text: action.payload }
    case 'reset':
      return INITIAL_STATE
  }
}

function CounterComponent() {
  const [state, dispatch] = useReducer(reducer, INITIAL_STATE)
  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment', payload: 3 })}>Sumar 3</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>Restar 1</button>
      <input
        value={state.text}
        onChange={e => dispatch({ type: 'set_text', payload: e.target.value })}
      />
      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>
    </div>
  )
}
```

Tipar de esta manera el `action.type`, te permitir√° que donde uses el m√©todo `dispatch` al comenzar a llenar `type` te dar√° las opciones cl√°sicas de un tipado de TypeScript.
Puede que la configuraci√≥n del proyecto que exija que las funciones sean tipadas.

```tsx
// crea un tipado del STATE
type StateType = {
  count: number;
  text: string;
  extraProperty: null | boolean;
}

const INITIAL_STATE: StateType = {
  count: 0,
  text: "",
  extraProperty: null
};

function reducer(state: StateType, action: ActionType): StateType {
...
}
```

**useEffect**

En el caso de useEffect y como estamos usando TypeScript, lo cual implica que seamos un poco m√°s estrictos con nuestro c√≥digo, es importante que tengas cuidado con lo que retornas.

```tsx
import { useEffect } from 'react'

type Props = {
  timerMs: number
}

function SomeComponent({ timerMs }: Props) {
  useEffect(
    () =>
      setTimeout(() => {
        // hacer cualquier cosa
      }, timerMs),
    [timerMs]
  )

  return null
}
```

Este ejemplo est√° mal, porque TypeScript y React se quejar√°n. Recuerda meter las funciones dentro de llaves `{}`.

```tsx
import { useEffect } from 'react'

type Props = {
  timerMs: number
}

function SomeComponent({ timerMs }: Props) {
  useEffect(() => {
    setTimeout(() => {
      // hacer cualquier cosa
    }, timerMs)
  }, [timerMs])

  return null
}
```

**useRef**

Aqu√≠ hay que tener mucho cuidado, porque la manera en que lo hagas, puede ocasionar problemas.
Debes considerar, que useRef, cuando se utiliza con elementos `HTMLElements`, el primer render retornar√° someRef.current => null.

Te muestro 3 maneras.

```tsx
const _ref1 = useRef<HTMLDivElement>(null!)
const _ref2 = useRef<HTMLDivElement>(null)
const _ref3 = useRef<HTMLDivElement | null>(null)
```

Primero, hablemos del `HTMLDivElement`. Este existe dentro de `@types/react`, por lo cual, estar√© libre para usar, incluso sin necesidad de importar desde ning√∫n lado. No todos los types o interfaces est√°n libres de esta manera, pero en este caso s√≠, como tambi√©n todos los dem√°s HTMLElements.

El primer ejemplo utiliza el operador non-null. No obstante, es como que le estuvieras mintiendo a TypeScript. Puede que tambi√©n en tu `tsconfig.json`, est√© el modo strictNullChecks, y eso cambia muchas cosas. Este operador, afirma que cualquier expresi√≥n no es null o undifined. Con esta mentira, le puedes usar \_ref1.current sin validar si es null o no.

El segundo ejemplo, indica lo b√°sico. \_ref2.current comienza como null, pero luego cambia al elemento referenciado. Este ejemplo, inferir√° al \_ref2 como un `RefObject`, que no es lo mismo que `MutableRefObject`. Como lo podr√°s "inferir" (broma typescriptera) por el nombre, el RefObject es un objeto cuya propiedad `current` no podr√° ser reasignada. Por lo cual, si en alg√∫n momento est√°s teniendo un error con un `ref`, verifica su tipado.

En este punto es cuando comienzas a pensar: ¬øc√≥mo pod√≠a desarrollar antes sin tipados?... bueno quiz√°s no, pero yo si lo pienso.

_Nota importante: si est√°s en un entorno de Nextjs con TypeScript, desconozco el porqu√©, pero el segundo ejemplo, retorna MutableRefObject igual, pero mejor prevenir._

Y el tercer ejemplo, como lo podr√°s nuevamente "inferir" ü•¥, es `MutableRefObject`.

Qu√© pasa con **useCallback y useMemo**

Independiente o no que tengas reglas de eslint que te obliguen a tipar las funciones, para el caso de useCallback, autom√°ticamente se inferir√°, por ende, no se necesita hacer nada.

En el caso de useMemo, ocurre algo similar.

Te quiero invitar a que te metas a leer los tipados de las librer√≠as que uses y los m√©todos o funciones que est√©s importando. Cada vez que crezcas m√°s con TypeScript, podr√°s entender mejor cada una de las cosas que usas. Sin duda, esto no evitar√° cometer errores, pero si los disminuir√°.

**Hooks pesonalizados**

Debes tener cuidado si quieres devolver un array en tu hook personalizado, similar al hook `useState` ([state, setState]), porque TypeScript inferir√° como una union type. Por lo cual, tendr√≠as que manejarlo con la palabra clave `as` que es un tipo de afirmaci√≥n, que considere al objeto como otro tipo seg√∫n el que le est√©s dando, en vez del que infiere por si solo. Mejor vamos a un ejemplo:

```tsx
export function useLoading() {
  const [isLoading, setIsLoading] = useState<boolean>(false)

  // el uso de `any` en este ejemplo, es solo como ejemplo, deber√≠as evitar siempre usar any.
  const load = (somePromise: Promise<any>) => {
    setState(true)
    return somePromise.finally(() => setState(false))
  }
  return [isLoading, load] as const
}
```

Alternativa con tupla.

```tsx
export function useLoading() {
  const [isLoading, setIsLoading] = useState<boolean>(false);

  const load = (somePromise: Promise<any>) => {
    setState(true);
    return somePromise.finally(() => setState(false));
  };
  return [isLoading, load] as [
    boolean,
    (somePromise: Promise<any>): Promise<any>
  ];
}
```

Los del equipo de React recomiendan que los hooks personalizados que retornen m√°s de dos valores, deber√≠an usar objetos reales en lugar de tuplas.

### ¬øQu√© pasa con las defaultProps?

Bueno, el equipo de React no toma las cosas a la ligera cuando dice o indica cosas respecto a React.

Seg√∫n un t[weet de Dan Abramov en mayo 2019](https://twitter.com/dan_abramov/status/1133883672153792512 'weet de Dan Abramov en mayo 2019'), indica que las defaultProps eventualmente ser√°n deprecadas.

### Formularios y Eventos

Mi primer consejo, es que pongas el mouse sobre las cosas que usas, para ver sus tipados. Por ejemplo, un input es muy f√°cil de tipar el evento de `onChange` si te das el tiempo de observar bien.

Por ejemplo, si defines la funci√≥n dentro del m√©todo onChange y no como una funci√≥n por fuera, el `event` estar√° inferido autom√°ticamente.

```tsx
import { useState } from 'react'

function SomeComponent() {
  const [text, setText] = useState<string>('')

  return (
    // dentro del onChange, el evento `e` ser√°: e: ChangeEvent<HTMLInputElement>
    <input type='text' value={text} onChange={e => setText(e.target.value)} />
  )
}
```

Pero tipando ser√≠a as√≠:

```tsx
import { useState, ChangeEvent } from 'react'

function SomeComponent() {
  const [text, setText] = useState<string>('')

  // debes importar obviamente de React el ChangeEvent.
  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    setText(e.target.value)
  }

  return <input type='text' value={text} onChange={handleChange} />
}
```

ChangeEvent est√° extendido de `SyntheticEvent`. Tambi√©n puedes usar `FormEvent<HTMLInputElement>`, con la diferencia que para obtener el value debe ser:
`e.currentTarget.value`. Tambi√©n FormEvent est√° extendido de SyntheticEvent.

Otra manera de definir la funci√≥n ser√≠a as√≠:

```tsx
// de manera inferida, el valor de `e` ser√° `ChangeEvent<HTMLInputElement>`
const handleChange: ChangeEventHandler<HTMLInputElement> = e => {
  setText(e.target.value)
}
```

Respecto al m√©todo `onSubmit` de una etiqueta `form`, puedes utilizar `SyntheticEvent` o `FormEvent<HTMLFormElement>`.

Eso s√≠, considera que si est√°s usando formularios no controlados, el querer acceder a un input con nombre personalizado, puede que no te sea tan f√°cil as√≠ nomas.
Hay que agregar un detalle.

```tsx
const handleSubmit = (e: SyntheticEvent) => {
  e.preventDefault();
  const target = e.target as typeof e.target & {
    name: { value: string };
  };
  console.log(target.name.value);
};

...
<input name="name" type="text" />
```

Es solo una gu√≠a b√°sica, as√≠ que con este punto de partida para los formularios y eventos, puedes hacer mucho m√°s si sigues investigando y analizando los tipados que vienen en React.

### Context

Si llevas tiempo trabajando con React, los Context son pan de cada d√≠a. En alg√∫n momento habr√°s usado muchos contexts, luego pocos, luego muchos, etc. No importa si usas muchos. Es muy t√≠pica esa pregunta. Facebook en su aplicaci√≥n web, utiliza muchos, como dijo una vez **Dan Abramov**, lo importante es que lo hagas bien y que no tengas problemas con los re-renders, pero eso es otro tema.

En el caso de Context, lo importante es tipar el `value`.

```tsx
import { createContext, ReactNode, useContext, useState } from 'react'

type MyContextType = {
  name: string
  changeName: (newName: string) => void
}

const MyContext = createContext<MyContextType>({} as MyContextType)

type Props = {
  children: ReactNode
}

function MyContextProvider(props: Props) {
  const [name, setName] = useState<string>('')

  const changeName = (newName: string) => setName(newName)

  return <MyContext.Provider value={{ name, changeName }} {...props} />
}

function useMyContext() {
  const context = useContext(MyContext)
  if (context === undifined)
    throw new Error('useMyContext must be used within a MyContextProvider')
  return context
}

export { MyContextProvider, useMyContext }
```

Este es un ejemplo de uso t√≠pico de definir un Context y luego exportar el `Provider` y el `useContext`.

### forwardRef

Si te has envuelto en la necesidad de `forwardRef` por ejemplo, creando una librer√≠a UI con React y llega un momento en que queres utilizar un `ref` pero te diste cuenta que el componente definido no tiene `ref`, lo primero que he visto que mucha gente hace es pasar `ref` como una Prop.

Aqu√≠ React inmediatamente te dir√° que `ref` no es una prop y te dar√° una pista mencionando `forwardRef`.

Comento esto por si nunca lo has utilizado.

As√≠ deber√≠a ser c√≥mo utilices `forwardRef` con TypeScript:

```tsx
import { forwardRef, ReactNode } from 'react'

type Props = {
  children: ReactNode
  status: 'loading' | 'success'
}
type Ref = HTMLDivElement

const MyStatusBox = forwardRef<Ref, Props>(({ children, status }, ref) => {
  return (
    <div ref={ref} className={status}>
      {children}
    </div>
  )
})

MyStatusBox.displayName = 'MyStatusBox'
```

### Portales

Si has usado `ReactDOM.createPortal` esto te interesar√°.

Es un ejemplo muy b√°sico.

```tsx
import { ReactNode } from 'react'
import ReactDOM from 'react-dom'

type Props = {
  children: ReactNode
}

function MyPortal({ children }: Props) {
  const _rootDom = document.body

  return ReactDOM.createPortal(children, _rootDom)
}
```

Y bueno, eso! jejeje

Es solo una gu√≠a b√°sica, con algunos peque√±os detalles, que permiten sobrevivir.

Est√°s justo entrando a un trabajo que te piden TypeScript pero no has trabajado a√∫n as√≠? solo sabes React con JavaScript?
Bueno, la idea de esta mini gu√≠a es que tengas algunas opciones para sobrevivir.

Creo que el consejo m√°s importante y significativo que te puedo dar, es el usar el MOUSE.

S√≠, el mouse, para inferir tipados.
Tambi√©n la t√©cnica del `typeof` es otra alternativa. Esto te salvar√° muchas veces cuando no sepas como tipar algo de una librer√≠a de terceros.
Otra cosa es recordar que no todas las dependencias de NPM est√°n tipadas, a veces tienes que instalar `@types/la_dependencia`. Y a veces, tampoco existe. Ah√≠ creo que llego la hora de sufrir jajaja, porque si no encuentras una dependencia alternativa que si est√© tipada, tendr√°s que hacerlo t√∫ y eso ya es harina de otro costal. Espero nunca te pase. En mi caso, me est√° pasando ahora con `neo4j-graphql-js`. Pero pronto estar√° listo el tipado que se est√° generando comunitariamente.

En fin, espero que te sirva un poco esta **Gu√≠a b√°sica de Supervivencia en React con TypeScript**.

Te recomiendo algunas lecturas m√°s completas y adicionales para asuntos m√°s complejos:

- https://react-typescript-cheatsheet.netlify.app/
- La misma pero en espa√±ol: https://github.com/typescript-cheatsheets/react-typescript-cheatsheet-es

Abrazos

export const post = getPostByUrl('guia-basica-de-supervivencia-en-react-con-typescript')

export default ({ children }) => (
  <LayoutPost
    date={post.date}
    dateForISO={post.dateForISO}
    title={post.title}
    description={post.description}
    image={post.image}
    url={post.url}>
    {children}
  </LayoutPost>
)
