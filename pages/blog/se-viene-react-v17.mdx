import { LayoutPost } from 'components/layout/post'
import { meta } from '_posts/se-viene-react-v17'

export default LayoutPost({ ...meta })

Hoy se ha publicado en el blog oficial de React el primer Release Candidate para React 17, luego de dos a침os y medio desde el 칰ltimo release importante (ha pasado bastante no?).

## No tiene nuevas funciones

La versi칩n 17 de React es bastante inusual, como dicen en el blog, porque no agrega ninguna caracter칤stica nueva para desarrolladores. Es decir, si esper치bamos nuevos hooks para hacer otras cosas locas, no vendr치 nada de esto.

Esta nueva versi칩n se est치 centrando principalmente en **facilitar la actualizaci칩n de React**.

No hay que asustarse al pensar que no est치n trabajando en nuevas funcionalidades, al contrario, pero no forman parte de esta versi칩n.

El enfoque est치 en **no dejar a nadie atr치s**. React 17 es una versi칩n **"trampol칤n"** que hace que sea m치s seguro insertar un 치rbol administraro por una versi칩n de React dentro de un 치rbol administrado por una versi칩n diferente de React.

## Actualizaciones graduales

Durante los 칰ltimos siete a침os, las actualizaciones de React han sido de "todo o nada". O te quedabas con una versi칩n anterior o actualizas toda la aplicaci칩n a una nueva versi칩n. No hubo intermedios.

Esto hab칤a funcionado hasta ahora, pero React est치 llegando a los l칤mites de esa estrategia de actualizaci칩n (todo o nada). Algunos cambios de API, por ejemplo, la desaprobaci칩n de la *API de Contexto heredado*, son imposibles de realizar de una forma automatizada. Aunque la mayor칤a de las aplicaciones escritas hoy en d칤a nunca las usan, a칰n se admiten en React. Se tendr칤a que elegir entre admitirlas en React indefinitivamente o dejar algunas aplicaciones en una versi칩n anterior de React, donde ambas opciones no son muy buenas.

Por eso es que se han enfocado en otra opci칩n.

React 17 va a permitir actualizaciones graduales de React. Cuando actualices React 15 a 16 (o 16 a 17 游땸), generalmente actualizar치 toda la aplicaci칩n de una vez. Esto funciona bien para muchas aplicaciones, pero puede volverse cada vez m치s desafiante si el c칩digo base se escribi칩 hace m치s de unos a침os y no se mantiene. Aunque es posible usar dos versiones de React en una misma p치gina, hasta React 17 esto ha sido fr치gil y ha causado problemas con los eventos.

En React est치n solucionando muchos de estos problemas con React 17. Esto significa que cuando salga React 18 y las pr칩ximas futuras versiones, ahora habr치n m치s opciones.

La primera opci칩n ser치 actualizar toda la aplicaci칩n de una vez, como podr칤a haber hecho antes. Pero tambi칠n tendr치 la opci칩n de actualizar la aplicaci칩n pieza por pieza. Por ejemplo, se podr치 decidir migrar la mayor parte de una aplicaci칩n a React 18, pero mantener un cuadro de di치logo cargado de forma diferida a una subruta en React 17.

OJO: Esto no significa que se deben hacer mejoras graduales. Para la mayor칤a de las aplicaciones, actualizar todo de una vez sigue siendo la mejor soluci칩n. Cargar dos versiones de React, incluso si una de ellas se carga de forma Lazy a pedido, todav칤a no es lo ideal. Sin embargo, para aplicaciones m치s grandes que no se mantienen, es una opci칩n que puede tener sentido y React 17 permitir치 que estas aplicaciones no se queden atr치s.

Para habilitar las actualizaciones graduales, necesitamos realizar algunos cambios en el sistema de eventos de React. La versi칩n 17 es importante porque estos cambios potencialmente se est치 rompiendo. En la pr치ctica, solo se ha tenido que cambiar menos de 20 componentes de m치s de 100 mil, por lo que esperan, en React, que la mayor칤a de las aplicaciones puedan actualizarse a React 17 sin demasiados problemas. (ahora m치s en la pr치ctica, puede que haya problemas igual no?)

Hay un repositorio de ejemplo que demuestra c칩mo cargar de forma diferida una versi칩n anterior de React si es necesario. Es una demo que utiliza CRA (create-react-app), pero deber칤a ser posible seguir un enfoque similar con cualquier otra herramienta. [Aqu칤 el demo.](https://github.com/reactjs/react-gradual-upgrade-demo/ "Aqu칤 el demo.")

Algo importante que ellos mencionan:

> Se han pospuesto otros cambios hasta despu칠s de React 17. Porque si el objetivo de esta versi칩n es ayudar a la actualizaci칩n y a no dejar a nadie atr치s, pero la actualizaci칩n se torna demasiado dif칤cil, estar칤a totalmente frustrado el prop칩sito.

## Cambios en Event Delegation

T칠cnicamente, siempre ha sido posible anidar aplicaciones desarrolladas con diferentes versiones de React, pero es bastante fr치gil debido a c칩mo funcionaba el sistema de eventos de React.

En los componentes de React, usualmente se escriben controladores de eventos en l칤nea.

```jsx
<button onClick={handleClick}>
```

El c칩digo equivalente en DOM vanilla es algo como:

```js
myButton.addEventListener('click', handleClick)
```

Sin imbargo, para la mayor칤a de los eventos, React no los adjunta a los nodos DOM en los que los declara. En cambio, React adjunta un controlador por tipo de evento directamente en el nodo `document`. A esto se le llama **event delegation**. Adem치s de sus beneficios de rendimiento en 치rboles grandes de una aplicaci칩n, tambi칠n facilita la edici칩n de nuevas funciones como la **reproducci칩n de eventos**.

React ha estado delegando eventos autom치ticamente desde el primer lanzamiento. Cuando un evento DOM se dispara en el document, React determina a qu칠 componente llamar, y luego el evento React "burbujea" hacia arriba a trav칠s de sus componentes. Pero detr치s de escena, el evento nativo ya ha subido al nivel `document`, donde React instala sus controladores de eventos.

Sin embargo, este es un problema para las actualizaciones graduales.

Si tienes varias versiones de React en la p치gina, todas se registran controladores de eventos en la parte superior. Esto rompe `e.stopProgataion()`: si un 치rbol anidado ha detenido la propagaci칩n de un evento, el 치rbol externo a칰n no lo recibir치. Esto hizo que fuera dif칤cil anidar diferentes versiones de React. Esta preocupaci칩n, como mencionan ellos, no es hipot칠tica; por ejemplo, el editor Atom se encontr칩 con esto hace cuatro a침os.

Es por eso (y luego de esta explicaci칩n anterior) que en React est치n cambiando la forma en que se adjunte los eventos al DOM debajo del cap칩.

**En React 17, ya no se adjuntar치 controladores de eventos en el nivel `document`. En cambio, los adjuntar치 al contenedor DOM ra칤z en el que se representa su 치rbol:**

```jsx
const rootNode = document.getElementById('root')
ReactDOM.render(<App />, rootNode)
```

En React 16 y versiones anteriores, React `document.addEventListener()` funcionar칤a para la mayor칤a de eventos. React 17 llamar치 a `rootNode.addEventListener()` debajo del cap칩 en su lugar.

Gracias a este importante cambio, ahora es m치s seguro incrustar un 치rbol de React administrado por una versi칩n dentro de un 치rbol administrado por una versi칩n de React diferente. Hay quer tener en cuenta que, para que esto funcione, ambas versiones deber칤an ser 17 o superior, por lo que es importante actualizar a la versi칩n 17. En cierto modo, React 17 es un release de "trampol칤n", que hace factible adelantarse a las futuras actualizaciones.

Este cambio tambi칠n facilita la integraci칩n de React en aplicaciones creadas con otras tecnolog칤as. Por ejemplo, si el "shell" externo de una aplicaci칩n est치 escrito en jQuery, pero el c칩digo m치s nuevo dentro de 칠l est치 escrito con React, `e.stopPropagation()` dentro del c칩digo React ahora evitar칤a que alcance el c칩digo jQuery, como era de esperar. Esto tambi칠n funciona en direcci칩n contraria. Si ya no nos gustar치 React y dese치ramos reescribir la aplicaci칩n, por ejemplo, en jQuery, se puede comenzar a convertir el shel externo de React a jQuery sin interrumpir la propagaci칩n del evento.

En React han confirmado que numerosos problemas reportados a lo largo de los a침os relacionado con la integraci칩n de React con c칩digo que no es de React.

En el caso de los **Portales**, React tambi칠n escucha eventos de 칠l, as칤 que no es un problema.

### Solucionar problemas potenciales

Al igual que con cualquier cambio importante, es probable que sea necesario ajustar alg칰n c칩digo. En Facebook, tuvieron que ajustar unos 10 m칩dulos en total (de muchos miles) para trabajar con este cambio.

Por ejemplo, si se agrega listeners manuales al DOM con `document.addEventListener(...)` se puede esperar que capturen todos los eventos React. En React 16 y versiones anteriores, incluso si llama `e.stopPropagation()` a un controlador de eventos React, los listeners `document` personalizados a칰n lo recibir칤an porque el evento nativo ya est치 en el nivel del document. Con React 17, la propagaci칩n se detendr칤a (!seg칰n lo solicitado!), por que sus controladores `document` no disparar칤an:

```js
document.addEventListener('click', function() {
	// este controlador no recibir치 m치s clics
	// de los componentes de React que llamen e.stopPropagation()
})
```

Se puede corregir un c칩digo como este convirtiendo el listener para usar la fase de captura. Para hace esto, se puede pasar `{ capture: true }` como tercer argumento a `document.addEventListener`:

```js
document.addEventListener('click', function() {
	// ahora este controlador de evento usa la fase de captura
	// por lo que recibe *todos* los eventos de clic que siguen
}, { capture: true })
```

Hay que tener en cuenta c칩mo esta estrategia es m치s resistente en general; por ejemplo, probablemente solucionar치 los errores existentes en el c칩digo que ocurren cuando `e.stopPropagation()` se llame fuera de un controlador de eventos de React. En otras palabras, la propagaci칩n de eventos en React 17 funciona m치s cerca del DOM normal.


------------

## Otros cambios importantes

Se ha mantenido los cambios importantes en React 17 al m칤nimo. Por ejemplo, no elimina ninguno de los m칠todos que han quedado obsoletos en versiones anteriores. Sin embargo, incluye algunos otros cambios importantes que han sido relativamente seguros la experiencia de React. En total, han tenido que ajustar menos de 20 de cada 100.000+ de los componentes debido a ellos.

### Alineando con los navegadores

Se han realizado un par de cambios m치s peque침os relacionados con el sistema de eventos:

- El evento `onScroll` **ya no burbujea** para evitar una confusi칩n com칰n.
- Los eventos React `onFocus` y `onBlur` han cambiado al uso de eventos nativos `focusin` y `focusout` bajo el cap칩, que se ajustan m치s al comportamiento existente de React y, a veces, brindan informaci칩n adicional.
- Los eventos de la fase de captura (ej: `onClickCapture`) ahora utilizan listeners de fase de captura reales de navegador.

Estos cambios alinean React m치s cerca del comportamiento del navegador y mejorar la interoperabilidad.

### Sin agrupaci칩n de eventos

React 17 elimina la optimizaci칩n de "agrupaci칩n de ventos" de React. No mejora el rendimiento en los navegadores modernos y confunde incluso a los usuarios experimentados de React:

```jsx
function handleChange(e) {
	setData(data => ({
		...data,
		// esto hace crash en React 16 y anteriores
		text: e.target.value
	}))
}
```

Esto se debe a que React reutiliz칩 los objetos de eventos entre diferentes eventos para el rendimiento en navegadores antiguos y estableci칩 todos los campos de eventos `null` entre ellos. Con React 16 y versiones anteriores, se debe llamar a `e.persist()` para usar correctamente el evento o leer la propiedad que se necesita antes.

**En React 17, este c칩digo funciona como era de esperar. La antigua optimizaci칩n de agrupaci칩n de eventos se ha eliminado por completo, por lo que se puede leer los campos de eventos siempre que se necesite.**

Este es un cambio de comportamiento, por lo que est치n marcando como roto, pero en la pr치ctica no lo han visto romper nada en Facebook. (!Quiz치s incluso solucion칩 algunos errores!). Hay que tener en cuenta que `e.persist()` todav칤a est치 disponible en el objeto de evento React, pero ahora no hace nada.

### Effect Cleanup Timing

Est치n haciendo que la sincronizaci칩n de la funci칩n de limpieza de `useEffect` sea m치s consistente.

```jsx
useEffect(() => {
	// este es el efecto en s칤
	return () => {
		// esto es un limpiador
	}
})
```

La mayor칤a de los efectos no necesitan retrasar las actualizaciones de la pantalla, por lo que React los ejecuta de forma asincr칩nica poco despu칠s de que la actualizaci칩n se refleje en la pantalla. (Para los casos excepcionales en los que se necesite un efecto para bloquear el paint, por ejemplo, para medir y colocar una informaci칩n sobre herramientas, hay que preferir `useLayoutEffect`).

Sin embargo, cuando se desmonta un componente, las funciones de *limpieza* del efecto se utilizan para ejecutarse sincr칩nicamente (similar a `componentWillUnmount` de manera sincr칩nica en las clases). Han descubierto que esto no es ideal para aplicaciones m치s grandes porque relentiza las transiciones de pantalla grande (por ejemplo, cambiar de pesta침a).

**En React 17, la funci칩n de limpieza de efectos siempre se ejecutar치 de forma asincr칩nica; por ejemplo, si el componente se est치 desmontando, la limpieza se ejecutar치 despu칠s de que se haya actualizado la pantalla.**

Esto refleja c칩mo los efectos en s칤 se ejecutan m치s de cerca. En los raros casos en los que desee confiar en la ejecuci칩n sincr칩nica, se puede cambiar a `useLayoutEffect`.

Adem치s, React 17 siempre ejecutar치 todas las funciones de limpieza de efectos (para todos los componentes) antes de ejecutar cualquier efecto nuevo. React 16 solo garantiz칩 este orden para los efectos dentro de un componente.

### Problemas potenciales

Solo han visto un par de componentes que se rompen con este cambio, aunque es posible que las bibliotecas reutilizables deban probarlo m치s a fondo. Un ejemplo de c칩digo con problemas puede verse as칤:

```jsx
useEffect(() => {
	someRef.current.someSetupMethod()
	return () => {
		someRef.current.someCleanupMethod()
	}
})
```

El problema es que el `someRef.current` es mutable, por lo que cuando se ejecuta la funci칩n de limpieza, es posible que se haya configurado en `null`. La soluci칩n es capturar cualquier valor mutable *dentro* del efecto:

```jsx
useEffect(() => {
	const instance = someRef.current
	instance.someSetupMethod()
	return () => {
		instance.someCleanupMethod()
	}
})
```

No esperan que esto sea un problema com칰n porque la regla de eslint **eslint-plugin-react-hooks/exhaustive-deps** (!칰sala!) siempre ha advertido sobre esto.

### Errores consistentes para devolver undefined

En React 16 y versiones anteriores, regresar `undefined` siempre ha sido un error:

```jsx
function Button() {
	return // error: nada ha retornado
}
```

Esto se debe en parte a que es f치cil volver `undefined` sin querer:

```jsx
function Button() {
	// hemos olvidado escribir return, por lo tanto este componente retorna undefined
	// React muestra esto como un error en lugar de ignorarlo
	<button />
}
```

Anteriormente, React solo hac칤a esto para los componentes de clase y funci칩n, pero no verificaba los valores de retorno de `forwardRef` y los componentes `memo`. Esto se debi칩 a un error de codificaci칩n.

En React 17, el comportamiento de los componentes forwardRef y memo, es coherente con los componentes de clase y funciones regulares. Retornar undefined de ellos es un error.

```jsx
let Button = forwardRef(() => {
	// hemos olvidado escribir return, por lo tanto este componente retorna undefined
	// React 17 muestra esto como un error en lugar de ignorarlo
	<button />
})

let Button = memo(() => {
	// hemos olvidado escribir return, por lo tanto este componente retorna undefined
	// React 17 muestra esto como un error en lugar de ignorarlo
	<button />
})
```

Para los casos en los que no se desee representar nada intencionalmente, se debe retornar `null` en su lugar.

### Stack de componentes nativos

Cuando el navegador arroja un error, el navegador proporciona un seguimiento del stack con los nombres de las funciones de JavaScript y sus ubicaciones. Sin embargo, los stack de JavaScript no suelen ser suficientes para diagnosticar un problema porque la jerarqu칤a del 치rbol de React puede ser igualmente importante. Se desea saber no solo que `Button` arroj칩 un error, sino tambi칠n en qu칠 parte del 치rbol de React el `Button`se encuentra.

Para resolver esto, React 16 comenz칩 a imprimir "stack de componentes" cuando se tiene un error. A칰n as칤, sol칤an ser inferiores a los stack de JavaScript nativos. En particular, no se pod칤a hacer clic en la consola porque React no sab칤a d칩nde se declar칩 la funci칩n en el c칩digo fuente. Adem치s, en su mayor칤a fueron in칰tiles en la producci칩n. A diferencia de los stack de JavaScript minificados regulares que se pueden restaurar autom치ticamente a los nombres de las funciones originales con un mapa de origen, con los stack de componentes de React se ten칤a que elegir entre el stack de producci칩n y tama침o de paquete.

**En React 17, los stack de componentes se generan utilizando un mecanismo diferente que las une a los stack de JavaScript nativos normales. Esto permite obtener los seguimientos del stack de componentes de React completamente simbolizados en un entorno de producci칩n.**

La forma en que React implementa esto es algo poco ortodoxo. Actualmente, los navegadores no proporcionan una forma de obtener el marco del stack de una funci칩n (archivo de origen y ubicaci칩n). Entonces, cuando React detecta un error, ahora reconstruir치 su stack de componentes lanzados (y capturando) un error temporal desde el interior de cada uno de los componentes anteriores, cuando sea posible. Esto agrega una peque침a penalizaci칩n de rendimiento por fallas, pero solo ocurre una vez por tipo de componente.

Esta parte constituye un cambio importante para que esto funcione, React vuelve a ejecutar partes de algunas de las funciones de React y los constructores de la clase React anteriores en la pila despu칠s de que se captura un error. Dado que las funciones de renderizado y los constructores de clases no deber칤an tener efectos secundarios (que tambi칠n es importante para la renderizaci칩n del servidor), esto no deber칤a plantear ning칰n problema pr치ctico.

### Eliminaci칩n de exportaciones privadas

Finalmente (s칤, por fin dir치s 游뱕), el 칰ltimo cambio notable es que han eliminado algunos componentes internos de React que estaba expuestos anteriormente a otros proyectos. En particular, React Native para Web, sol칤a depender de algunos componentes internos del sistema de eventos, pero esa dependencia era fr치gil y sol칤a romperse.

**En React 17, estas exportaciones privadas se han eliminado. Hasta donde saben, React Native para Web fue el 칰nico proyecto que las us칩, y ya completaron una migraci칩n a un enfoque diferente que no depende de esas exportaciones privadas.**

Esto significa que las versiones anteriores de React Native para Web, no ser치n compatibles con React 17, pero las versiones m치s nuevas funcionar치n con 칠l. En la pr치ctica, esto no cambia mucho porque React Native para Web tuvo que lanzar nuevas versiones para adaptarse a los cambios internos de React de todos modos.

Adem치s, han eliminado los m칠todos auxiliares `ReactTestUtils.SimulateNative`. Nunca se han documentado, no hicieron exactamente lo que sus nombres implicaban y no funcionaron con los cambios que se hicieron en el sistema de eventos. Si se desea una forma conveniente de activar eventos nativos del navegador en los tests, ver [React Testing Library](https://testing-library.com/docs/dom-testing-library/api-events "React Testing Library").

## Para probar / Instalaci칩n

Si quieres probar el release candidate React 17.0 pronto y as칤 tambi칠n plantear alg칰n problema que puedas encontrar, debes tener en cuenta que es m치s probable que una versi칩n candidata contenga errores que una versi칩n estable, as칤 que no la implementes todav칤a en producci칩n.

Para instalar React 17 RC con NPM, debes ejecutar:

```bash
npm install react@17.0.0-rc.2 react-dom@17.0.0-rc.2
```

Para instalar React 17 RC con Yarn, debes ejecutar:

```bash
yarn add react@17.0.0-rc.2 react-dom@17.0.0-rc.2
```

Tambi칠n se ha proporcionado compilaciones UMD de React a trav칠s de una CDN:

```html
<script crossorigin src="https://unpkg.com/react@17.0.0-rc.2/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@17.0.0-rc.2/umd/react-dom.production.min.js"></script>
```

Uff que largo.

Fuente: https://reactjs.org/blog/2020/08/10/react-v17-rc.html (ingl칠s)