import { LayoutPost } from 'components/layout/post'
import { meta } from '_posts/formatos-nativos-de-javascript-para-fechas'

export default LayoutPost({ ...meta })

Por mucho tiempo, para manejar fechas, horas y sus formatos he sido un usuario de **moment.js** y t√∫?

Bueno, tambi√©n de **date-fns** üò¨.

Las fechas en muchas ocasiones, han sido un dolor de cabeza, con los formatos y todo eso. Pero tambi√©n lo son los tama√±os de las librer√≠as.

No te quiero asustar, pero te invito a que veas por ti: [Bundle Phobia de Moment.js](https://bundlephobia.com/result?p=moment@2.28.0 "Bundle Phobia de Moment.js")

Te podr√°s dar cuenta que en su √∫ltima versi√≥n, el peso de moment es de 280.9kB minimizado y con gzip es de 70.4kB. Eso es much√≠simo.

Muchas veces, el instalar moment para un simple formateo de fecha, es innecesario, aunque si no tienes otra forma de hacerlo, es innevitable.

> Si bien, hoy por hoy, uso **Luxon** (69.7kB minimizado y 20.5kB gzip), que es de los mismos creadores de Moment, mucho m√°s peque√±o, sencilla de usar y una dependencia que recomiendo much√≠simo. As√≠ que si est√°s entre la espada y la pared para combatir con las fechas, usa Luxon.

Cuando naci√≥ moment, era porque necesit√°bamos una forma de poder manejar las fechas, horas, d√≠as, tiempo, que en JavaScript no ten√≠amos, o mejor dicho, JavaScript no lo ten√≠a tan desarrollado de manera nativa. Hab√≠an ciertos m√©todos, pero no estaban maduros. No obstante, hoy JavaScript est√° mucho m√°s avanzado y es eso que quiero mostrarte.

Me refiero a los m√©todos **toLocaleDateString**, **toLocaleTimeString** y **toLocaleString**.

La [compatibilidad en navegadores](https://caniuse.com/date-tolocaledatestring "compatibilidad en navegadores") de estos m√©todos es bastante buena.

Si bien, estos tres m√©todos podr√≠an ser casi iguales, tienen ciertas diferencias que veremos al final, pero lo primero que me gustar√≠a decir, es que, el lenguaje construye realidades, y en el caso de estos m√©todos, podr√≠amos entenderlos en base a sus nombres.

Estos m√©todos reciben dos argumentos opcionales: el "locales" y las "opciones".

```js
date.nombreDelM√©todo(locales, options)
```

Una prueba b√°sica nos dar√≠a esto:

```js
const date = new Date('05/18/2020')
console.log(date.toLocaleDateString())
// 5/18/2020
console.log(date.toLocaleTimeString())
// 12:00:00 AM
console.log(date.toLocaleString())
// 5/18/2020, 12:00:00 AM
```

El primer argumento, **locales**, es la configuraci√≥n regional. Puede ser una etiqueta BCP-47 como string o un array de etiquetas del idioma espec√≠fico. (un BCP qu√©? mejor revisa [aqu√≠](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Intl "aqu√≠")). Un ejemplo podr√≠a ser: "es-CL", que indicar√≠a el lenguaje espa√±ol usado en Chile.

Si no se entrega el primer argumento (undefined), tomar√° por defecto la configuraci√≥n predeterminada de la aplicaci√≥n, el navegador, etc.

El segundo argumento, **options**, es un objeto que puede incluir varias opciones.

Para **toLocaleDateString** tenemos weekday, month, year y day. Si no se usa options, estas opciones son undefined. Al mismo tiempo, cada una de estas opciones, tiene opciones internas.

- weekday: narrow, short y long
- year: numeric y 2-digit
- month: numeric, 2-digit, narrow, short y long
- day: numeric y 2-digit

```js
const date = new Date('05/18/2020')
const options = {
  weekday: 'long',
  year: 'numeric',
  month: 'long',
  day: 'numeric'
}
console.log(date.toLocaleDateString('es-CL', options))
// lunes, 18 de mayo de 2020
```

Para el caso de **toLocaleTimeString**, que hace referencia a la hora, las opciones son timeZone, hour12, hour, minute, second.

- timeZone: el nombre como string de cada zona, ej: America/Santiago
- hour12: true o false
- hour: numeric, 2-digit
- minute: numeric, 2-digit
- second: numeric, 2-digit

```js
const date = new Date('05/18/2020')
const options = {
  timeZone: 'America/Santiago',
  hour12: true,
  hour: 'numeric',
  minute: '2-digit',
  second: '2-digit'
}
console.log(date.toLocaleTimeString('es-CL', options))
// 0:00:00 a.¬†m.
```

Finalmente, para el caso de **toLocaleString**, como es una combinaci√≥n de ambas anteriores, las opciones que utilice son las que indicar√°n tambi√©n que resultado tendr√© al ingresar los argumentos.

```js
const date = new Date('05/18/2020')
const options = {
  weekday: 'long',
  year: 'numeric',
  month: 'long',
  day: 'numeric',
  timeZone: 'America/Santiago',
  hour12: true,
  hour: 'numeric',
  minute: '2-digit',
  second: '2-digit'
}
console.log(date.toLocaleString('es-CL', options))
// lunes, 18 de mayo de 2020 0:00:00 a.¬†m.
```

Bueno, as√≠ vamos entendiendo que podr√≠an haber muchas combinaciones posibles que podr√≠an servir.

Por ejemplo:

```js
const date = new Date('05/18/2020')
const options = {
  month: 'short',
  day: 'numeric'
}
console.log(date.toLocaleDateString('es-CL', options))
// 18 may.
```

```js
const date = new Date('05/18/2020')
const options = {
  month: 'long'
}
console.log(date.toLocaleDateString('es-CL', options))
// mayo
```

```js
const date = new Date('05/18/2020')
const options = {
  hour12: true,
  hour: '2-digit'
}
console.log(date.toLocaleTimeString('es-CL', options))
// 00 a.¬†m.
```

En fin, hay varias opciones que puedes usar dependiendo de tus necesidades.

Si bien es cierto, estas m√∫ltiples combinaciones posibles, pueden hacer m√°s sencillo el manejo de fechas y horas, ten en cuenta, lo mencionado antes, *compatibilidad*.

No obstante, si el cambio es muy grande desde moment a los m√©todos nativos, la mejor transici√≥n ser√≠a con Luxon.

Espero que este peque√±o post sobre algunos m√©todos nativos para el manejo de fechas y horas, te haya sido √∫til.

Gracias por leer üòÄ.