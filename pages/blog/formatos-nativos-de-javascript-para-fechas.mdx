import LayoutPost from 'components/layout/post'
import { meta } from '_posts/formatos-nativos-de-javascript-para-fechas'

Por mucho tiempo, para manejar fechas, horas y sus formatos he sido un usuario de **moment.js** y tÃº?

Bueno, tambiÃ©n de **date-fns** ğŸ˜¬.

Las fechas en muchas ocasiones, han sido un dolor de cabeza, con los formatos y todo eso. Pero tambiÃ©n lo son los tamaÃ±os de las librerÃ­as.

No te quiero asustar, pero te invito a que veas por ti: [Bundle Phobia de Moment.js](https://bundlephobia.com/result?p=moment@2.28.0 "Bundle Phobia de Moment.js")

Te podrÃ¡s dar cuenta que en su Ãºltima versiÃ³n, el peso de moment es de 280.9kB minimizado y con gzip es de 70.4kB. Eso es muchÃ­simo.

Muchas veces, el instalar moment para un simple formateo de fecha, es innecesario, aunque si no tienes otra forma de hacerlo, es innevitable.

> Si bien, hoy por hoy, uso **Luxon** (69.7kB minimizado y 20.5kB gzip), que es de los mismos creadores de Moment, mucho mÃ¡s pequeÃ±o, sencilla de usar y una dependencia que recomiendo muchÃ­simo. AsÃ­ que si estÃ¡s entre la espada y la pared para combatir con las fechas, usa Luxon.

Cuando naciÃ³ moment, era porque necesitÃ¡bamos una forma de poder manejar las fechas, horas, dÃ­as, tiempo, que en JavaScript no tenÃ­amos, o mejor dicho, JavaScript no lo tenÃ­a tan desarrollado de manera nativa. HabÃ­an ciertos mÃ©todos, pero no estaban maduros. No obstante, hoy JavaScript estÃ¡ mucho mÃ¡s avanzado y es eso que quiero mostrarte.

Me refiero a los mÃ©todos **toLocaleDateString**, **toLocaleTimeString** y **toLocaleString**.

La [compatibilidad en navegadores](https://caniuse.com/date-tolocaledatestring "compatibilidad en navegadores") de estos mÃ©todos es bastante buena.

Si bien, estos tres mÃ©todos podrÃ­an ser casi iguales, tienen ciertas diferencias que veremos al final, pero lo primero que me gustarÃ­a decir, es que, el lenguaje construye realidades, y en el caso de estos mÃ©todos, podrÃ­amos entenderlos en base a sus nombres.

Estos mÃ©todos reciben dos argumentos opcionales: el "locales" y las "opciones".

```js
date.nombreDelMÃ©todo(locales, options)
```

Una prueba bÃ¡sica nos darÃ­a esto:

```js
const date = new Date('05/18/2020')
console.log(date.toLocaleDateString())
// 5/18/2020
console.log(date.toLocaleTimeString())
// 12:00:00 AM
console.log(date.toLocaleString())
// 5/18/2020, 12:00:00 AM
```

El primer argumento, **locales**, es la configuraciÃ³n regional. Puede ser una etiqueta BCP-47 como string o un array de etiquetas del idioma especÃ­fico. (un BCP quÃ©? mejor revisa [aquÃ­](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Intl "aquÃ­")). Un ejemplo podrÃ­a ser: "es-CL", que indicarÃ­a el lenguaje espaÃ±ol usado en Chile.

Si no se entrega el primer argumento (undefined), tomarÃ¡ por defecto la configuraciÃ³n predeterminada de la aplicaciÃ³n, el navegador, etc.

El segundo argumento, **options**, es un objeto que puede incluir varias opciones.

Para **toLocaleDateString** tenemos weekday, month, year y day. Si no se usa options, estas opciones son undefined. Al mismo tiempo, cada una de estas opciones, tiene opciones internas.

- weekday: narrow, short y long
- year: numeric y 2-digit
- month: numeric, 2-digit, narrow, short y long
- day: numeric y 2-digit

```js
const date = new Date('05/18/2020')
const options = {
  weekday: 'long',
  year: 'numeric',
  month: 'long',
  day: 'numeric'
}
console.log(date.toLocaleDateString('es-CL', options))
// lunes, 18 de mayo de 2020
```

Para el caso de **toLocaleTimeString**, que hace referencia a la hora, las opciones son timeZone, hour12, hour, minute, second.

- timeZone: el nombre como string de cada zona, ej: America/Santiago
- hour12: true o false
- hour: numeric, 2-digit
- minute: numeric, 2-digit
- second: numeric, 2-digit

```js
const date = new Date('05/18/2020')
const options = {
  timeZone: 'America/Santiago',
  hour12: true,
  hour: 'numeric',
  minute: '2-digit',
  second: '2-digit'
}
console.log(date.toLocaleTimeString('es-CL', options))
// 0:00:00 a.Â m.
```

Finalmente, para el caso de **toLocaleString**, como es una combinaciÃ³n de ambas anteriores, las opciones que utilice son las que indicarÃ¡n tambiÃ©n que resultado tendrÃ© al ingresar los argumentos.

```js
const date = new Date('05/18/2020')
const options = {
  weekday: 'long',
  year: 'numeric',
  month: 'long',
  day: 'numeric',
  timeZone: 'America/Santiago',
  hour12: true,
  hour: 'numeric',
  minute: '2-digit',
  second: '2-digit'
}
console.log(date.toLocaleString('es-CL', options))
// lunes, 18 de mayo de 2020 0:00:00 a.Â m.
```

Bueno, asÃ­ vamos entendiendo que podrÃ­an haber muchas combinaciones posibles que podrÃ­an servir.

Por ejemplo:

```js
const date = new Date('05/18/2020')
const options = {
  month: 'short',
  day: 'numeric'
}
console.log(date.toLocaleDateString('es-CL', options))
// 18 may.
```

```js
const date = new Date('05/18/2020')
const options = {
  month: 'long'
}
console.log(date.toLocaleDateString('es-CL', options))
// mayo
```

```js
const date = new Date('05/18/2020')
const options = {
  hour12: true,
  hour: '2-digit'
}
console.log(date.toLocaleTimeString('es-CL', options))
// 00 a.Â m.
```

En fin, hay varias opciones que puedes usar dependiendo de tus necesidades.

Si bien es cierto, estas mÃºltiples combinaciones posibles, pueden hacer mÃ¡s sencillo el manejo de fechas y horas, ten en cuenta, lo mencionado antes, *compatibilidad*.

No obstante, si el cambio es muy grande desde moment a los mÃ©todos nativos, la mejor transiciÃ³n serÃ­a con Luxon.

Espero que este pequeÃ±o post sobre algunos mÃ©todos nativos para el manejo de fechas y horas, te haya sido Ãºtil.

Gracias por leer ğŸ˜€.

export default ({children}) => <LayoutPost { ...meta }>{children}</LayoutPost>